<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>7.10 - Context API</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="container">
        <h1>7.10 - Context API</h1>
        
        <div class="teoria">
            <h2>Cos'√® il Context?</h2>
            <p>Il <strong>Context API</strong> permette di condividere dati "globali" nell'albero dei componenti 
            senza passare props manualmente ad ogni livello (risolve il props drilling).</p>
            
            <h3>Quando Usare Context?</h3>
            <ul>
                <li>‚úÖ <strong>Dati globali:</strong> Tema, lingua, autenticazione utente</li>
                <li>‚úÖ <strong>Props drilling profondo:</strong> >3-4 livelli di componenti</li>
                <li>‚úÖ <strong>Molti componenti:</strong> Tanti componenti necessitano degli stessi dati</li>
                <li>‚ùå <strong>Non per tutto:</strong> State locale rimane preferibile quando possibile</li>
            </ul>
        </div>
        
        <div class="teoria">
            <h2>Creare e Usare Context</h2>
            
            <h3>1. Creare il Context</h3>
            <div class="codice">
<pre>import { createContext } from 'react'

// Crea context con valore di default
const ThemeContext = createContext('light')  // Default: 'light'</pre>
            </div>
            
            <h3>2. Fornire il Context (Provider)</h3>
            <div class="codice">
<pre>import { useState } from 'react'

function App() {
  const [theme, setTheme] = useState('light')
  
  return (
    // Provider rende theme disponibile a tutti i children
    &lt;ThemeContext.Provider value={theme}&gt;
      &lt;Toolbar /&gt;
      &lt;Dashboard /&gt;
    &lt;/ThemeContext.Provider&gt;
  )
}</pre>
            </div>
            
            <h3>3. Consumare il Context (useContext)</h3>
            <div class="codice">
<pre>import { useContext } from 'react'

function Button() {
  // Leggi valore dal context
  const theme = useContext(ThemeContext)
  
  return (
    &lt;button className={`btn-${theme}`}&gt;
      Click me
    &lt;/button&gt;
  )
}

function Card() {
  const theme = useContext(ThemeContext)
  
  return (
    &lt;div className={`card-${theme}`}&gt;
      Card content
    &lt;/div&gt;
  )
}

// ‚úÖ Button e Card accedono a theme senza props!</pre>
            </div>
        </div>
        
        <div class="teoria">
            <h2>Esempio Completo: Theme Context</h2>
            
            <div class="codice">
<pre>import { createContext, useState, useContext } from 'react'

// 1. Crea Context
const ThemeContext = createContext()

// 2. Provider Component
function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light')
  
  const toggleTheme = () =&gt; {
    setTheme(prev =&gt; prev === 'light' ? 'dark' : 'light')
  }
  
  // Value contiene sia state che funzioni
  const value = {
    theme,
    toggleTheme
  }
  
  return (
    &lt;ThemeContext.Provider value={value}&gt;
      {children}
    &lt;/ThemeContext.Provider&gt;
  )
}

// 3. Custom Hook per accedere al Context
function useTheme() {
  const context = useContext(ThemeContext)
  
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider')
  }
  
  return context
}

// 4. Componenti che usano il Context
function ThemeToggle() {
  const { theme, toggleTheme } = useTheme()
  
  return (
    &lt;button onClick={toggleTheme}&gt;
      Tema attuale: {theme}
    &lt;/button&gt;
  )
}

function Card() {
  const { theme } = useTheme()
  
  return (
    &lt;div className={`card ${theme}`}&gt;
      Questa card usa il tema {theme}
    &lt;/div&gt;
  )
}

function Navbar() {
  const { theme } = useTheme()
  
  return (
    &lt;nav className={`navbar ${theme}`}&gt;
      Navbar con tema {theme}
    &lt;/nav&gt;
  )
}

// 5. App root
function App() {
  return (
    &lt;ThemeProvider&gt;
      &lt;ThemeToggle /&gt;
      &lt;Navbar /&gt;
      &lt;Card /&gt;
    &lt;/ThemeProvider&gt;
  )
}

// ‚úÖ Tutti i componenti accedono a theme senza props drilling!</pre>
            </div>
        </div>
        
        <div class="teoria">
            <h2>Auth Context (Esempio Reale)</h2>
            
            <div class="codice">
<pre>import { createContext, useState, useContext, useEffect } from 'react'

const AuthContext = createContext()

export function AuthProvider({ children }) {
  const [user, setUser] = useState(null)
  const [loading, setLoading] = useState(true)
  
  // Check authentication al mount
  useEffect(() =&gt; {
    const checkAuth = async () =&gt; {
      try {
        const response = await fetch('/api/auth/me')
        const userData = await response.json()
        setUser(userData)
      } catch (error) {
        setUser(null)
      } finally {
        setLoading(false)
      }
    }
    
    checkAuth()
  }, [])
  
  const login = async (email, password) =&gt; {
    const response = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password })
    })
    
    const userData = await response.json()
    setUser(userData)
  }
  
  const logout = async () =&gt; {
    await fetch('/api/auth/logout', { method: 'POST' })
    setUser(null)
  }
  
  const value = {
    user,
    loading,
    login,
    logout,
    isAuthenticated: !!user
  }
  
  return (
    &lt;AuthContext.Provider value={value}&gt;
      {children}
    &lt;/AuthContext.Provider&gt;
  )
}

// Custom hook
export function useAuth() {
  const context = useContext(AuthContext)
  
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider')
  }
  
  return context
}

// Uso nei componenti
function Navbar() {
  const { user, logout, isAuthenticated } = useAuth()
  
  return (
    &lt;nav&gt;
      {isAuthenticated ? (
        &lt;&gt;
          &lt;span&gt;Benvenuto, {user.name}!&lt;/span&gt;
          &lt;button onClick={logout}&gt;Logout&lt;/button&gt;
        &lt;/&gt;
      ) : (
        &lt;a href="/login"&gt;Login&lt;/a&gt;
      )}
    &lt;/nav&gt;
  )
}

function ProtectedPage() {
  const { isAuthenticated, loading } = useAuth()
  
  if (loading) return &lt;p&gt;Loading...&lt;/p&gt;
  if (!isAuthenticated) return &lt;p&gt;Accesso negato&lt;/p&gt;
  
  return &lt;h1&gt;Contenuto protetto&lt;/h1&gt;
}

// App
function App() {
  return (
    &lt;AuthProvider&gt;
      &lt;Navbar /&gt;
      &lt;ProtectedPage /&gt;
    &lt;/AuthProvider&gt;
  )
}</pre>
            </div>
        </div>
        
        <div class="teoria">
            <h2>Multiple Contexts</h2>
            <p>Puoi usare pi√π Context contemporaneamente per separare concerns.</p>
            
            <div class="codice">
<pre>import { ThemeProvider } from './contexts/ThemeContext'
import { AuthProvider } from './contexts/AuthContext'
import { CartProvider } from './contexts/CartContext'

function App() {
  return (
    &lt;AuthProvider&gt;
      &lt;ThemeProvider&gt;
        &lt;CartProvider&gt;
          &lt;Dashboard /&gt;
        &lt;/CartProvider&gt;
      &lt;/ThemeProvider&gt;
    &lt;/AuthProvider&gt;
  )
}

// Dashboard pu√≤ usare tutti i context
function Dashboard() {
  const { user } = useAuth()
  const { theme } = useTheme()
  const { items } = useCart()
  
  return (
    &lt;div className={theme}&gt;
      &lt;h1&gt;Benvenuto {user.name}&lt;/h1&gt;
      &lt;p&gt;Carrello: {items.length} items&lt;/p&gt;
    &lt;/div&gt;
  )
}</pre>
            </div>
        </div>
        
        <div class="teoria">
            <h2>Context con Reducer (Avanzato)</h2>
            <p>Combina Context + useReducer per gestione state complessa.</p>
            
            <div class="codice">
<pre>import { createContext, useContext, useReducer } from 'react'

// Reducer
function cartReducer(state, action) {
  switch (action.type) {
    case 'ADD_ITEM':
      return {
        ...state,
        items: [...state.items, action.payload]
      }
    
    case 'REMOVE_ITEM':
      return {
        ...state,
        items: state.items.filter(item =&gt; item.id !== action.payload)
      }
    
    case 'CLEAR_CART':
      return {
        ...state,
        items: []
      }
    
    default:
      return state
  }
}

// Context
const CartContext = createContext()

// Provider
export function CartProvider({ children }) {
  const [state, dispatch] = useReducer(cartReducer, { items: [] })
  
  const addItem = (item) =&gt; {
    dispatch({ type: 'ADD_ITEM', payload: item })
  }
  
  const removeItem = (id) =&gt; {
    dispatch({ type: 'REMOVE_ITEM', payload: id })
  }
  
  const clearCart = () =&gt; {
    dispatch({ type: 'CLEAR_CART' })
  }
  
  const value = {
    items: state.items,
    addItem,
    removeItem,
    clearCart,
    itemCount: state.items.length
  }
  
  return (
    &lt;CartContext.Provider value={value}&gt;
      {children}
    &lt;/CartContext.Provider&gt;
  )
}

// Hook
export function useCart() {
  const context = useContext(CartContext)
  
  if (!context) {
    throw new Error('useCart must be used within CartProvider')
  }
  
  return context
}

// Uso
function ProductCard({ product }) {
  const { addItem } = useCart()
  
  return (
    &lt;div&gt;
      &lt;h3&gt;{product.name}&lt;/h3&gt;
      &lt;button onClick={() =&gt; addItem(product)}&gt;
        Aggiungi al carrello
      &lt;/button&gt;
    &lt;/div&gt;
  )
}

function CartSummary() {
  const { items, itemCount, clearCart } = useCart()
  
  return (
    &lt;div&gt;
      &lt;h2&gt;Carrello ({itemCount})&lt;/h2&gt;
      &lt;ul&gt;
        {items.map(item =&gt; &lt;li key={item.id}&gt;{item.name}&lt;/li&gt;)}
      &lt;/ul&gt;
      &lt;button onClick={clearCart}&gt;Svuota carrello&lt;/button&gt;
    &lt;/div&gt;
  )
}</pre>
            </div>
        </div>
        
        <div class="teoria">
            <h2>Performance: React.memo con Context</h2>
            
            <div class="codice">
<pre>import { memo } from 'react'

// ‚ö†Ô∏è PROBLEMA: Tutti i componenti re-renderizzano quando context cambia
const ExpensiveChild = memo(function ExpensiveChild() {
  console.log('ExpensiveChild rendered')
  // Componente pesante
})

// ‚úÖ SOLUZIONE: Separa context in pi√π context specifici
const UserContext = createContext()
const ThemeContext = createContext()  // Separato da user

function App() {
  const [user, setUser] = useState(null)
  const [theme, setTheme] = useState('light')
  
  return (
    &lt;UserContext.Provider value={user}&gt;
      &lt;ThemeContext.Provider value={theme}&gt;
        {/* ExpensiveChild re-renderizza solo se theme cambia */}
        &lt;ExpensiveChild /&gt;
      &lt;/ThemeContext.Provider&gt;
    &lt;/UserContext.Provider&gt;
  )
}</pre>
            </div>
        </div>
        
        <div class="best-practices">
            <h2>üéØ Best Practices</h2>
            <ul>
                <li>‚úÖ <strong>Custom Hook:</strong> Sempre crea <code>useNome()</code> per accedere al context</li>
                <li>‚úÖ <strong>Error handling:</strong> Verifica che context sia usato dentro Provider</li>
                <li>‚úÖ <strong>File separati:</strong> Context in file <code>contexts/ThemeContext.jsx</code></li>
                <li>‚úÖ <strong>Separation of concerns:</strong> Un context per tipo di dato (auth, theme, cart)</li>
                <li>‚úÖ <strong>Provider composition:</strong> Pi√π provider per dati diversi</li>
                <li>‚úÖ <strong>useReducer:</strong> Per state complesso usa Context + useReducer</li>
                <li>‚ö†Ô∏è <strong>Performance:</strong> Separa context che cambiano spesso da quelli statici</li>
                <li>‚ùå Non usare Context per tutto (preferisci state locale quando possibile)</li>
                <li>‚ùå Non mettere troppi dati in un singolo context</li>
            </ul>
        </div>
        
        <div class="navigazione">
            <a href="lezione-7-9.html" class="btn-nav">‚Üê Lezione Precedente</a>
            <a href="index.html" class="btn-nav">üìö Indice</a>
            <a href="lezione-7-99.html" class="btn-nav">Progetto Finale ‚Üí</a>
        </div>
    </div>
</body>
</html>
