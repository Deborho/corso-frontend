<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>5.3 - React Fondamenti</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>5.3 - React Fondamenti</h1>
            <p>Imparare React costruendo un gioco interattivo</p>
        </div>

        <div class="teoria">
            <h2>Obiettivi</h2>
            <p>Imparare i fondamenti di React costruendo step-by-step un gioco Tris (Tic-Tac-Toe) interattivo, seguendo il tutorial ufficiale di React.</p>
        </div>

        <h2>1. Cos'√® React?</h2>
        
        <div class="teoria">
            <p><strong>React √® una libreria JavaScript per costruire interfacce utente</strong> basate su componenti riutilizzabili. Sviluppata da Meta (Facebook), √® la libreria UI pi√π popolare al mondo.</p>
            
            <h3>Concetti Chiave</h3>
            <ul>
                <li><strong>Componenti:</strong> Pezzi di UI riutilizzabili (come funzioni che ritornano HTML)</li>
                <li><strong>Props:</strong> Dati passati ai componenti (come parametri di funzioni)</li>
                <li><strong>State:</strong> Dati che cambiano nel tempo e causano aggiornamenti automatici della UI</li>
                <li><strong>JSX:</strong> Sintassi che mescola HTML e JavaScript</li>
            </ul>
        </div>

        <h2>2. Creare un Componente</h2>

        <div class="teoria">
            <p>Un <strong>componente</strong> √® una funzione JavaScript che ritorna elementi da visualizzare. In React usiamo <strong>JSX</strong>, una sintassi che assomiglia a HTML ma √® JavaScript.</p>
            
            <h3>Caratteristiche</h3>
            <ul>
                <li>I componenti devono iniziare con lettera maiuscola (<code>Square</code>, non <code>square</code>)</li>
                <li>Possono ritornare solo un singolo elemento genitore</li>
                <li>Usa <code>className</code> invece di <code>class</code> per le classi CSS</li>
                <li>Le variabili JavaScript si inseriscono con <code>{}</code></li>
            </ul>
        </div>

        <div class="codice">
            <h3>Componente Semplice</h3>
            <pre><code>// Un componente base
function Square() {
    return <button className="square">X</button>;
}

// Usare il componente
function Board() {
    return (
        &lt;&gt;
            &lt;Square /&gt;
            &lt;Square /&gt;
            &lt;Square /&gt;
        &lt;/&gt;
    );
}</code></pre>
        </div>

        <div class="teoria">
            <h3>Fragment (&lt;&gt;&lt;/&gt;)</h3>
            <p>I componenti React devono ritornare un singolo elemento. Se hai pi√π elementi da ritornare, avvolgili in un <strong>Fragment</strong> (<code>&lt;&gt;...&lt;/&gt;</code>) invece di un div inutile.</p>
        </div>

        <h2>3. Props - Passare Dati ai Componenti</h2>

        <div class="teoria">
            <p>Le <strong>props</strong> (properties) permettono di passare dati da un componente genitore a uno figlio. Funzionano come i parametri delle funzioni.</p>
            
            <h3>Come Funzionano</h3>
            <ul>
                <li>Il genitore passa dati con la sintassi <code>&lt;Component value="X" /&gt;</code></li>
                <li>Il figlio riceve i dati come oggetto: <code>function Component({ value }) { }</code></li>
                <li>Le props sono <strong>read-only</strong> - il componente figlio non pu√≤ modificarle</li>
            </ul>
        </div>

        <div class="codice">
            <h3>Passare e Ricevere Props</h3>
            <pre><code>// Componente che riceve una prop
function Square({ value }) {
    return <button className="square">{value}</button>;
}

// Componente genitore che passa props
function Board() {
    return (
        &lt;&gt;
            &lt;Square value="1" /&gt;
            &lt;Square value="2" /&gt;
            &lt;Square value="3" /&gt;
        &lt;/&gt;
    );
}</code></pre>
        </div>

        <div class="teoria">
            <h3>Interpolazione in JSX</h3>
            <p>Per usare una variabile JavaScript dentro JSX, avvolgila in <code>{}</code>. Senza le graffe, JSX mostra la parola letterale "value" invece del valore della variabile.</p>
        </div>

        <h2>4. Gestire Eventi</h2>

        <div class="teoria">
            <p>React permette di rispondere agli eventi utente (click, input, ecc.) usando props speciali come <code>onClick</code>, <code>onChange</code>, ecc.</p>
            
            <h3>Regole degli Event Handler</h3>
            <ul>
                <li>Passa una <strong>funzione</strong>, non chiamarla: <code>onClick={handleClick}</code>, non <code>onClick={handleClick()}</code></li>
                <li>Se chiami la funzione con <code>()</code>, verr√† eseguita subito durante il render, causando loop infiniti</li>
                <li>Per passare parametri, usa arrow function: <code>onClick={() => handleClick(0)}</code></li>
            </ul>
        </div>

        <div class="codice">
            <h3>Gestire Click</h3>
            <pre><code>function Square({ value }) {
    function handleClick() {
        console.log('Cliccato!');
    }
    
    return (
        <button className="square" onClick={handleClick}>
            {value}
        </button>
    );
}</code></pre>
        </div>

        <h2>5. State - Memorizzare Dati</h2>

        <div class="teoria">
            <p>Lo <strong>state</strong> √® la "memoria" del componente. Quando lo state cambia, React ri-renderizza automaticamente il componente per mostrare i nuovi dati.</p>
            
            <h3>useState Hook</h3>
            <p>Per usare lo state, importa <code>useState</code> da React:</p>
            <ul>
                <li><code>const [value, setValue] = useState(null)</code></li>
                <li><code>value</code> √® il valore corrente</li>
                <li><code>setValue</code> √® la funzione per cambiarlo</li>
                <li><code>null</code> √® il valore iniziale</li>
            </ul>
        </div>

        <div class="codice">
            <h3>Usare useState</h3>
            <pre><code>import { useState } from 'react';

function Square() {
    const [value, setValue] = useState(null);
    
    function handleClick() {
        setValue('X');  // Cambia il valore e ri-renderizza
    }
    
    return (
        <button className="square" onClick={handleClick}>
            {value}
        </button>
    );
}</code></pre>
        </div>

        <div class="teoria">
            <h3>Come Funziona</h3>
            <ol>
                <li>L'utente clicca il bottone</li>
                <li>Viene chiamato <code>handleClick</code></li>
                <li><code>setValue('X')</code> cambia lo state</li>
                <li>React ri-renderizza automaticamente il componente</li>
                <li>Il bottone ora mostra "X"</li>
            </ol>
        </div>

        <h2>6. Lifting State Up - Condividere State</h2>

        <div class="teoria">
            <p>Quando pi√π componenti devono accedere agli stessi dati, <strong>sposta lo state nel loro componente genitore comune</strong>. Il genitore passer√† i dati ai figli tramite props.</p>
            
            <h3>Perch√©?</h3>
            <p>Ogni componente <code>Square</code> ha il proprio state indipendente. Per controllare il gioco (determinare il vincitore, alternare i giocatori), abbiamo bisogno di uno state condiviso nel componente <code>Board</code>.</p>
        </div>

        <div class="codice">
            <h3>State nel Genitore</h3>
            <pre><code>function Board() {
    const [squares, setSquares] = useState(Array(9).fill(null));
    
    function handleClick(i) {
        const nextSquares = squares.slice();  // Copia l'array
        nextSquares[i] = 'X';
        setSquares(nextSquares);
    }
    
    return (
        &lt;&gt;
            &lt;Square value={squares[0]} onSquareClick={() => handleClick(0)} /&gt;
            &lt;Square value={squares[1]} onSquareClick={() => handleClick(1)} /&gt;
            &lt;Square value={squares[2]} onSquareClick={() => handleClick(2)} /&gt;
        &lt;/&gt;
    );
}

function Square({ value, onSquareClick }) {
    return (
        <button className="square" onClick={onSquareClick}>
            {value}
        </button>
    );
}</code></pre>
        </div>

        <div class="teoria">
            <h3>Flusso dei Dati</h3>
            <ol>
                <li><code>Board</code> passa <code>value</code> e <code>onSquareClick</code> a <code>Square</code></li>
                <li>L'utente clicca su <code>Square</code></li>
                <li><code>Square</code> chiama <code>onSquareClick</code> (che √® <code>handleClick</code> del <code>Board</code>)</li>
                <li><code>handleClick</code> aggiorna <code>squares</code></li>
                <li>React ri-renderizza <code>Board</code> e tutti i suoi <code>Square</code></li>
            </ol>
        </div>

        <h2>7. Immutabilit√†</h2>

        <div class="teoria">
            <p>In React, <strong>non modificare mai direttamente lo state</strong>. Crea sempre una copia, modificala, poi passa la copia a <code>setState</code>.</p>
            
            <h3>Perch√© Immutabilit√†?</h3>
            <ul>
                <li><strong>Time travel:</strong> Mantenendo copie dello state, possiamo tornare indietro nella storia</li>
                <li><strong>Performance:</strong> React pu√≤ confrontare rapidamente se qualcosa √® cambiato</li>
                <li><strong>Debugging:</strong> Pi√π facile capire come √® cambiato lo state</li>
            </ul>
        </div>

        <div class="codice">
            <pre><code>// ‚ùå SBAGLIATO - Modifica diretta
function handleClick(i) {
    squares[i] = 'X';  // Mutazione diretta!
    setSquares(squares);
}

// ‚úÖ CORRETTO - Crea una copia
function handleClick(i) {
    const nextSquares = squares.slice();  // Copia l'array
    nextSquares[i] = 'X';
    setSquares(nextSquares);  // Passa la nuova copia
}</code></pre>
        </div>

        <h2>8. Turni Alternati</h2>

        <div class="teoria">
            <p>Per alternare tra X e O, aggiungiamo un altro pezzo di state che tiene traccia di quale giocatore √® il prossimo.</p>
        </div>

        <div class="codice">
            <pre><code>function Board() {
    const [xIsNext, setXIsNext] = useState(true);
    const [squares, setSquares] = useState(Array(9).fill(null));
    
    function handleClick(i) {
        if (squares[i]) {
            return;  // Casella gi√† occupata
        }
        
        const nextSquares = squares.slice();
        if (xIsNext) {
            nextSquares[i] = 'X';
        } else {
            nextSquares[i] = 'O';
        }
        setSquares(nextSquares);
        setXIsNext(!xIsNext);  // Alterna il giocatore
    }
    
    return (/* ... */);
}</code></pre>
        </div>

        <h2>9. Determinare il Vincitore</h2>

        <div class="teoria">
            <p>Per controllare se qualcuno ha vinto, creiamo una funzione helper che verifica tutte le combinazioni vincenti possibili.</p>
        </div>

        <div class="codice">
            <pre><code>function calculateWinner(squares) {
    const lines = [
        [0, 1, 2],  // Righe
        [3, 4, 5],
        [6, 7, 8],
        [0, 3, 6],  // Colonne
        [1, 4, 7],
        [2, 5, 8],
        [0, 4, 8],  // Diagonali
        [2, 4, 6],
    ];
    
    for (let i = 0; i < lines.length; i++) {
        const [a, b, c] = lines[i];
        if (squares[a] && 
            squares[a] === squares[b] && 
            squares[a] === squares[c]) {
            return squares[a];  // Ritorna 'X' o 'O'
        }
    }
    return null;  // Nessun vincitore
}

function Board() {
    // ...
    const winner = calculateWinner(squares);
    let status;
    if (winner) {
        status = 'Vincitore: ' + winner;
    } else {
        status = 'Prossimo giocatore: ' + (xIsNext ? 'X' : 'O');
    }
    
    return (
        &lt;&gt;
            &lt;div className="status"&gt;{status}&lt;/div&gt;
            {/* ... squares ... */}
        &lt;/&gt;
    );
}</code></pre>
        </div>

        <h2>10. Rendering di Liste</h2>

        <div class="teoria">
            <p>Per renderizzare liste di elementi in React, usiamo il metodo <code>map()</code> degli array. Ogni elemento della lista deve avere una <code>key</code> prop univoca.</p>
            
            <h3>Perch√© le Keys?</h3>
            <ul>
                <li>Aiutano React a identificare quali elementi sono cambiati, aggiunti o rimossi</li>
                <li>Migliorano le performance degli aggiornamenti</li>
                <li>Devono essere univoche tra elementi fratelli</li>
            </ul>
        </div>

        <div class="codice">
            <pre><code>function Game() {
    const [history, setHistory] = useState([Array(9).fill(null)]);
    
    // Trasforma history in una lista di bottoni
    const moves = history.map((squares, move) => {
        let description;
        if (move > 0) {
            description = 'Vai alla mossa #' + move;
        } else {
            description = 'Vai all\'inizio';
        }
        
        return (
            &lt;li key={move}&gt;
                &lt;button onClick={() => jumpTo(move)}&gt;
                    {description}
                &lt;/button&gt;
            &lt;/li&gt;
        );
    });
    
    return (
        &lt;div className="game"&gt;
            &lt;div className="game-board"&gt;
                &lt;Board /&gt;
            &lt;/div&gt;
            &lt;div className="game-info"&gt;
                &lt;ol&gt;{moves}&lt;/ol&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    );
}</code></pre>
        </div>

        <h2>11. Time Travel - Storia delle Mosse</h2>

        <div class="teoria">
            <p>Grazie all'immutabilit√†, possiamo salvare ogni stato della board in un array <code>history</code> e permettere agli utenti di tornare indietro nel gioco.</p>
            
            <h3>Struttura History</h3>
            <p>L'array <code>history</code> contiene tutti gli stati della board:</p>
        </div>

        <div class="codice">
            <pre><code>// history = [
//   [null, null, null, null, null, null, null, null, null],  // Inizio
//   [null, null, null, null, 'X', null, null, null, null],   // Mossa 1
//   [null, null, null, null, 'X', null, null, null, 'O'],    // Mossa 2
//   // ...
// ]

function Game() {
    const [history, setHistory] = useState([Array(9).fill(null)]);
    const [currentMove, setCurrentMove] = useState(0);
    const xIsNext = currentMove % 2 === 0;
    const currentSquares = history[currentMove];
    
    function handlePlay(nextSquares) {
        // Aggiungi la nuova mossa alla history
        const nextHistory = [...history.slice(0, currentMove + 1), nextSquares];
        setHistory(nextHistory);
        setCurrentMove(nextHistory.length - 1);
    }
    
    function jumpTo(nextMove) {
        setCurrentMove(nextMove);
    }
    
    return (/* ... */);
}</code></pre>
        </div>

        <div class="teoria">
            <h3>Come Funziona</h3>
            <ol>
                <li><code>history</code> salva tutti gli stati della board</li>
                <li><code>currentMove</code> indica quale stato stiamo visualizzando</li>
                <li>Quando l'utente clicca "Vai alla mossa #3", impostiamo <code>currentMove = 3</code></li>
                <li>React ri-renderizza mostrando lo stato al momento della mossa 3</li>
                <li>Se fai una nuova mossa da l√¨, la history viene "potata" fino a quel punto</li>
            </ol>
        </div>

        <h2>12. Ottimizzazione State</h2>

        <div class="teoria">
            <p>Una best practice importante: <strong>evita state ridondanti</strong>. Se puoi calcolare un valore dallo state esistente, non salvarlo in un nuovo state.</p>
        </div>

        <div class="codice">
            <pre><code>// ‚ùå RIDONDANTE - xIsNext pu√≤ essere calcolato da currentMove
function Game() {
    const [xIsNext, setXIsNext] = useState(true);
    const [currentMove, setCurrentMove] = useState(0);
    // ...
}

// ‚úÖ OTTIMIZZATO - calcoliamo xIsNext
function Game() {
    const [currentMove, setCurrentMove] = useState(0);
    const xIsNext = currentMove % 2 === 0;  // Calcolato!
    // ...
}

// Se currentMove √® pari (0, 2, 4...) √® il turno di X
// Se currentMove √® dispari (1, 3, 5...) √® il turno di O</code></pre>
        </div>

        <div class="teoria">
            <h3>Vantaggi</h3>
            <ul>
                <li>Meno state = meno bug (i due valori non possono andare fuori sincronia)</li>
                <li>Codice pi√π semplice</li>
                <li>Meno aggiornamenti di state da gestire</li>
            </ul>
        </div>

        <div class="teoria">
            <h2>Riepilogo Concetti React</h2>
            <table>
                <tr>
                    <th>Concetto</th>
                    <th>Cosa Fa</th>
                </tr>
                <tr>
                    <td>Componenti</td>
                    <td>Funzioni che ritornano UI (elementi JSX)</td>
                </tr>
                <tr>
                    <td>JSX</td>
                    <td>Sintassi HTML-like in JavaScript</td>
                </tr>
                <tr>
                    <td>Props</td>
                    <td>Dati passati dal genitore al figlio (read-only)</td>
                </tr>
                <tr>
                    <td>State (useState)</td>
                    <td>Memoria del componente, causa re-render quando cambia</td>
                </tr>
                <tr>
                    <td>Event Handlers</td>
                    <td>Funzioni che rispondono a eventi utente</td>
                </tr>
                <tr>
                    <td>Lifting State Up</td>
                    <td>Spostare state nel genitore per condividerlo</td>
                </tr>
                <tr>
                    <td>Immutabilit√†</td>
                    <td>Non modificare state direttamente, crea copie</td>
                </tr>
                <tr>
                    <td>Keys</td>
                    <td>Identificatori univoci per elementi di liste</td>
                </tr>
            </table>
        </div>

        <div class="teoria">
            <h2>Codice Completo: Gioco Tris</h2>
            <p>Ecco il codice completo del gioco Tris con tutte le funzionalit√†:</p>
        </div>

        <div class="codice">
            <pre><code>import { useState } from 'react';

function Square({ value, onSquareClick }) {
    return (
        &lt;button className="square" onClick={onSquareClick}&gt;
            {value}
        &lt;/button&gt;
    );
}

function Board({ xIsNext, squares, onPlay }) {
    function handleClick(i) {
        if (calculateWinner(squares) || squares[i]) {
            return;
        }
        const nextSquares = squares.slice();
        if (xIsNext) {
            nextSquares[i] = 'X';
        } else {
            nextSquares[i] = 'O';
        }
        onPlay(nextSquares);
    }

    const winner = calculateWinner(squares);
    let status;
    if (winner) {
        status = 'Vincitore: ' + winner;
    } else {
        status = 'Prossimo giocatore: ' + (xIsNext ? 'X' : 'O');
    }

    return (
        &lt;&gt;
            &lt;div className="status"&gt;{status}&lt;/div&gt;
            &lt;div className="board-row"&gt;
                &lt;Square value={squares[0]} onSquareClick={() => handleClick(0)} /&gt;
                &lt;Square value={squares[1]} onSquareClick={() => handleClick(1)} /&gt;
                &lt;Square value={squares[2]} onSquareClick={() => handleClick(2)} /&gt;
            &lt;/div&gt;
            &lt;div className="board-row"&gt;
                &lt;Square value={squares[3]} onSquareClick={() => handleClick(3)} /&gt;
                &lt;Square value={squares[4]} onSquareClick={() => handleClick(4)} /&gt;
                &lt;Square value={squares[5]} onSquareClick={() => handleClick(5)} /&gt;
            &lt;/div&gt;
            &lt;div className="board-row"&gt;
                &lt;Square value={squares[6]} onSquareClick={() => handleClick(6)} /&gt;
                &lt;Square value={squares[7]} onSquareClick={() => handleClick(7)} /&gt;
                &lt;Square value={squares[8]} onSquareClick={() => handleClick(8)} /&gt;
            &lt;/div&gt;
        &lt;/&gt;
    );
}

export default function Game() {
    const [history, setHistory] = useState([Array(9).fill(null)]);
    const [currentMove, setCurrentMove] = useState(0);
    const xIsNext = currentMove % 2 === 0;
    const currentSquares = history[currentMove];

    function handlePlay(nextSquares) {
        const nextHistory = [...history.slice(0, currentMove + 1), nextSquares];
        setHistory(nextHistory);
        setCurrentMove(nextHistory.length - 1);
    }

    function jumpTo(nextMove) {
        setCurrentMove(nextMove);
    }

    const moves = history.map((squares, move) => {
        let description;
        if (move > 0) {
            description = 'Vai alla mossa #' + move;
        } else {
            description = 'Vai all\'inizio del gioco';
        }
        return (
            &lt;li key={move}&gt;
                &lt;button onClick={() => jumpTo(move)}&gt;{description}&lt;/button&gt;
            &lt;/li&gt;
        );
    });

    return (
        &lt;div className="game"&gt;
            &lt;div className="game-board"&gt;
                &lt;Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} /&gt;
            &lt;/div&gt;
            &lt;div className="game-info"&gt;
                &lt;ol&gt;{moves}&lt;/ol&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    );
}

function calculateWinner(squares) {
    const lines = [
        [0, 1, 2],
        [3, 4, 5],
        [6, 7, 8],
        [0, 3, 6],
        [1, 4, 7],
        [2, 5, 8],
        [0, 4, 8],
        [2, 4, 6],
    ];
    for (let i = 0; i < lines.length; i++) {
        const [a, b, c] = lines[i];
        if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {
            return squares[a];
        }
    }
    return null;
}</code></pre>
        </div>

        <div class="teoria">
            <h2>Prossimi Passi</h2>
            <p>Congratulazioni! Hai imparato i fondamenti di React. Questi concetti sono la base di qualsiasi applicazione React:</p>
            <ul>
                <li>‚úÖ Creare e comporre componenti</li>
                <li>‚úÖ Passare dati con props</li>
                <li>‚úÖ Gestire state con useState</li>
                <li>‚úÖ Rispondere a eventi</li>
                <li>‚úÖ Lifting state up per condividere dati</li>
                <li>‚úÖ Renderizzare liste con map e keys</li>
                <li>‚úÖ Mantenere immutabilit√† dello state</li>
            </ul>
        </div>

        <div class="teoria">
            <h2>Tutorial Ufficiale React</h2>
            <p>Questa lezione √® basata sul tutorial ufficiale di React. Per approfondire e vedere il gioco in azione con un editor interattivo, visita:</p>
            <p>
                <a href="https://react.dev/learn/tutorial-tic-tac-toe" target="_blank" rel="noopener noreferrer" style="font-size: 1.1em; font-weight: bold;">
                    üîó Tutorial: Tic-Tac-Toe - React Official Docs
                </a>
            </p>
            <p>Il tutorial ufficiale include:</p>
            <ul>
                <li>Editor interattivo per provare il codice in tempo reale</li>
                <li>Esercizi aggiuntivi per praticare</li>
                <li>Spiegazioni pi√π approfondite</li>
                <li>Link a documentazione avanzata</li>
            </ul>
        </div>

        <div class="navigazione">
            <a href="/lezione-5/lezione-5-2.html" class="btn-prev">‚Üê Lezione Precedente</a>
            <a href="/index.html" class="btn-home">Home</a>
            <a href="/link-utili.html" class="btn-link-utili">Link Utili</a>
            <a href="https://react.dev/learn/tutorial-tic-tac-toe" class="btn-next">Progetto Finale ‚Üí</a>
        </div>
    </div>
</body>
</html>
