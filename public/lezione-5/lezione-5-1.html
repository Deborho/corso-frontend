<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>5.1 - Fondamenti JavaScript</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>5.1 - Fondamenti JavaScript</h1>
            <p>Le basi di JavaScript per iniziare lo sviluppo web moderno</p>
        </div>

        <div class="teoria">
            <h2>Obiettivi</h2>
            <p>Apprendere i concetti fondamentali di JavaScript necessari per comprendere TypeScript e React.</p>
        </div>

        <h2>1. Let e Const</h2>
        
        <div class="teoria">
            <p>In JavaScript moderno, <strong>let</strong> e <strong>const</strong> hanno sostituito <code>var</code> per la dichiarazione delle variabili. Queste nuove keyword introducono il <strong>block scope</strong> (ambito a livello di blocco), risolvendo problemi di scope che causavano bug difficili da identificare.</p>
            
            <h3>Perché var Causa Problemi</h3>
            <p>La keyword <code>var</code> presenta tre problemi principali:</p>
            <ul>
                <li><strong>Function Scope invece di Block Scope</strong>: Le variabili dichiarate con <code>var</code> sono visibili in tutta la funzione, anche fuori dai blocchi <code>if</code>, <code>for</code>, ecc. Questo causa "scope leaking" dove variabili possono essere accessibili in posti inaspettati.</li>
                <li><strong>Hoisting</strong>: Le dichiarazioni <code>var</code> vengono "sollevate" all'inizio della funzione, permettendo di usare variabili prima della loro dichiarazione (con valore <code>undefined</code>). Questo comportamento è confuso e può nascondere errori.</li>
                <li><strong>Ri-dichiarazione Permessa</strong>: Puoi dichiarare la stessa variabile più volte con <code>var</code> senza errori, sovrascrivendo accidentalmente valori esistenti.</li>
            </ul>
            
            <h3>Differenze Principali</h3>
            <ul>
                <li><strong>const</strong>: Non può essere riassegnata dopo la dichiarazione (immutabile), block scope</li>
                <li><strong>let</strong>: Può essere riassegnata, ha block scope</li>
                <li><strong>var</strong>: Ha function scope, causa problemi di hoisting e scope leaking - <strong>NON USARE</strong></li>
            </ul>
        </div>

        <div class="codice">
<pre><code>// ❌ Vecchio modo con var (problemi di scope)
var nome = "Mario";
if (true) {
    var nome = "Luigi";  // Sovrascrive la variabile esterna!
}
console.log(nome);  // "Luigi"

// ✅ Modo moderno con let
let cognome = "Rossi";
if (true) {
    let cognome = "Bianchi";  // Variabile diversa (block scope)
}
console.log(cognome);  // "Rossi"

// ✅ const per valori immutabili
const PI = 3.14159;
// PI = 3.14;  // ❌ Errore: non puoi riassegnare const

// ⚠️ Ma puoi modificare oggetti e array!
const utente = { nome: "Marco" };
utente.nome = "Paolo";  // ✅ OK
utente.eta = 25;        // ✅ OK
// utente = {};         // ❌ Errore: non puoi riassegnare</code></pre>
        </div>

        <div class="teoria">
            <h3>Regola Pratica</h3>
            <p>La best practice moderna è:</p>
            <ul>
                <li>Usa <strong>const</strong> di default (99% dei casi) - impedisce riassegnazioni accidentali</li>
                <li>Usa <strong>let</strong> solo quando sai che dovrai riassegnare la variabile (contatori, accumul atori)</li>
                <li>Non usare mai <strong>var</strong> - è deprecato e causa problemi</li>
            </ul>
        </div>

        <h3>Esempio Pratico</h3>

        <div class="codice">
<pre><code>// Esempio reale: gestione carrello e-commerce
const SCONTO_VIP = 0.15;  // Valore fisso, mai cambia
let totaleCarrello = 0;   // Verrà riassegnato ad ogni aggiunta

function aggiungiProdotto(prezzo) {
    totaleCarrello += prezzo;  // Riassegniamo let
}

function applicaSconto(isVip) {
    if (isVip) {
        const sconto = totaleCarrello * SCONTO_VIP;  // Variabile locale
        totaleCarrello -= sconto;
    }
    return totaleCarrello;
}

aggiungiProdotto(50);
aggiungiProdotto(30);
console.log(applicaSconto(true));  // 68 (80 - 15% sconto)</code></pre>
        </div>

        <h2>2. Funzioni</h2>

        <div class="teoria">
            <p>Le <strong>funzioni</strong> sono blocchi di codice riutilizzabili che eseguono un'azione specifica. In JavaScript, le funzioni sono "first-class citizens": possono essere assegnate a variabili, passate come argomenti e ritornate da altre funzioni.</p>
            
            <h3>Tipi di Dichiarazione</h3>
            <ul>
                <li><strong>Function declaration</strong>: <code>function nome() {}</code> - hoisted, disponibile prima della dichiarazione</li>
                <li><strong>Function expression</strong>: <code>const nome = function() {}</code> - non hoisted</li>
                <li><strong>Arrow function</strong>: <code>const nome = () => {}</code> - sintassi moderna e concisa</li>
            </ul>
        </div>

        <div class="codice">
            <h3>Dichiarazione e Sintassi</h3>
            <pre><code>// Function declaration (modo tradizionale)
function saluta(nome) {
    return "Ciao, " + nome + "!";
}

// Function expression
const saluta = function(nome) {
    return "Ciao, " + nome + "!";
};

// ✅ Arrow function (moderno)
const saluta = (nome) => {
    return "Ciao, " + nome + "!";
};

// ✅ Arrow function con return implicito
const saluta = nome => "Ciao, " + nome + "!";

// Funzione con parametri multipli
const somma = (a, b) => a + b;

// Parametri con valori di default
const saluta = (nome = "Ospite") => "Ciao, " + nome + "!";
console.log(saluta());  // "Ciao, Ospite!"</code></pre>
        </div>

        <h3>Esempio Pratico</h3>

        <div class="codice">
<pre><code>// Esempio reale: funzioni per e-commerce
const calcolaTotale = (prezzoBase, quantita) => prezzoBase * quantita;

const applicaSconto = (totale, percentualeSconto) => {
    const sconto = totale * (percentualeSconto / 100);
    return totale - sconto;
};

const aggiungiIVA = totale => totale * 1.22;

// Usare le funzioni
const prezzoBase = 50;
const quantita = 3;
const totale = calcolaTotale(prezzoBase, quantita);      // 150
const conSconto = applicaSconto(totale, 10);             // 135
const finale = aggiungiIVA(conSconto);                   // 164.70

console.log(`Prezzo finale: €${finale.toFixed(2)}`);     // "Prezzo finale: €164.70"</code></pre>
        </div>

        <h2>3. Oggetti</h2>

        <div class="teoria">
            <p>Gli <strong>oggetti</strong> sono collezioni di proprietà (coppie chiave-valore) che raggruppano dati correlati. Sono la struttura dati fondamentale in JavaScript e rappresentano entità del mondo reale con le loro caratteristiche.</p>
            
            <h3>Caratteristiche</h3>
            <ul>
                <li>Contengono proprietà (dati) e metodi (funzioni)</li>
                <li>Le proprietà si accedono con notazione punto (<code>oggetto.proprieta</code>) o parentesi (<code>oggetto['proprieta']</code>)</li>
                <li>Sono mutabili: puoi aggiungere, modificare o rimuovere proprietà</li>
                <li>Si passano per riferimento, non per valore</li>
            </ul>
        </div>

        <div class="codice">
            <h3>Creazione e Utilizzo</h3>
            <pre><code>// Creare un oggetto
const persona = {
    nome: "Mario",
    cognome: "Rossi",
    eta: 30,
    citta: "Roma",
    
    // Metodo: funzione dentro un oggetto
    saluta: function() {
        return `Ciao, sono ${this.nome}!`;
    }
};

// Accedere alle proprietà
console.log(persona.nome);          // "Mario"
console.log(persona["cognome"]);    // "Rossi"

// Modificare proprietà
persona.eta = 31;

// Aggiungere nuove proprietà
persona.professione = "Sviluppatore";

// Chiamare metodi
console.log(persona.saluta());      // "Ciao, sono Mario!"

// Notazione moderna per metodi
const utente = {
    nome: "Laura",
    saluta() {                       // Sintassi shorthand
        return `Ciao, sono ${this.nome}!`;
    }
};</code></pre>
        </div>

        <h3>Esempio Pratico</h3>

        <div class="codice">
<pre><code>// Esempio reale: prodotto e-commerce
const prodotto = {
    id: 101,
    nome: "Laptop",
    prezzo: 999,
    categoria: "Elettronica",
    disponibile: true,
    specifiche: {
        ram: "16GB",
        processore: "Intel i7",
        schermo: "15 pollici"
    },
    
    calcolaPrezzoConIVA() {
        return this.prezzo * 1.22;
    },
    
    applicaSconto(percentuale) {
        return this.prezzo * (1 - percentuale / 100);
    }
};

console.log(prodotto.nome);                          // "Laptop"
console.log(prodotto.specifiche.ram);                // "16GB"
console.log(prodotto.calcolaPrezzoConIVA());        // 1218.78
console.log(prodotto.applicaSconto(10));            // 899.10</code></pre>
        </div>

        <h2>4. Classi</h2>

        <div class="teoria">
            <p>Le <strong>classi</strong> sono template (modelli) per creare oggetti con struttura e comportamento simili. Introdotte in ES6, offrono una sintassi più chiara per la programmazione orientata agli oggetti rispetto ai prototipi tradizionali.</p>
            
            <h3>Concetti Base</h3>
            <ul>
                <li><strong>constructor</strong>: Metodo speciale chiamato quando si crea una nuova istanza</li>
                <li><strong>this</strong>: Si riferisce all'istanza corrente della classe</li>
                <li><strong>new</strong>: Keyword per creare una nuova istanza</li>
                <li><strong>Metodi</strong>: Funzioni definite nella classe, disponibili per tutte le istanze</li>
            </ul>
        </div>

        <div class="codice">
            <h3>Sintassi Base</h3>
            <pre><code>// Definire una classe
class Persona {
    // Constructor: inizializza l'oggetto
    constructor(nome, cognome, eta) {
        this.nome = nome;
        this.cognome = cognome;
        this.eta = eta;
    }
    
    // Metodi della classe
    saluta() {
        return `Ciao, sono ${this.nome} ${this.cognome}`;
    }
    
    compleanno() {
        this.eta++;
        return `Ora ho ${this.eta} anni!`;
    }
    
    // Getter: proprietà calcolata
    get nomeCompleto() {
        return `${this.nome} ${this.cognome}`;
    }
}

// Creare istanze (oggetti) dalla classe
const mario = new Persona("Mario", "Rossi", 30);
const laura = new Persona("Laura", "Bianchi", 25);

console.log(mario.saluta());          // "Ciao, sono Mario Rossi"
console.log(mario.nomeCompleto);      // "Mario Rossi"
console.log(mario.compleanno());      // "Ora ho 31 anni!"

// Ogni istanza è indipendente
console.log(laura.eta);               // 25 (non è cambiata)</code></pre>
        </div>

        <h3>Esempio Pratico</h3>

        <div class="codice">
<pre><code>// Esempio reale: gestione carrello e-commerce
class Carrello {
    constructor() {
        this.prodotti = [];
    }
    
    aggiungi(prodotto, quantita = 1) {
        this.prodotti.push({ ...prodotto, quantita });
        return `Aggiunto: ${prodotto.nome} x${quantita}`;
    }
    
    rimuovi(idProdotto) {
        this.prodotti = this.prodotti.filter(p => p.id !== idProdotto);
    }
    
    get totale() {
        return this.prodotti.reduce((sum, item) => {
            return sum + (item.prezzo * item.quantita);
        }, 0);
    }
    
    get numeroProdotti() {
        return this.prodotti.reduce((sum, item) => sum + item.quantita, 0);
    }
}

// Utilizzo
const carrello = new Carrello();
carrello.aggiungi({ id: 1, nome: "Laptop", prezzo: 999 }, 1);
carrello.aggiungi({ id: 2, nome: "Mouse", prezzo: 25 }, 2);

console.log(carrello.numeroProdotti);  // 3
console.log(carrello.totale);          // 1049</code></pre>
        </div>

        <h2>5. Iterazioni (Cicli)</h2>

        <div class="teoria">
            <p>I <strong>cicli</strong> permettono di eseguire codice ripetutamente. JavaScript offre diversi tipi di cicli per situazioni diverse: <code>for</code> per iterazioni con contatore, <code>while</code> per condizioni, e metodi di array come <code>forEach</code> per iterare su collezioni.</p>
            
            <h3>Quando Usare Quale Ciclo</h3>
            <ul>
                <li><strong>for</strong>: Quando sai quante iterazioni fare</li>
                <li><strong>while</strong>: Quando non sai quante iterazioni fare (dipende da una condizione)</li>
                <li><strong>forEach</strong>: Per iterare su array (più moderno e leggibile)</li>
                <li><strong>for...of</strong>: Per iterare su array con sintassi semplice</li>
            </ul>
        </div>

        <div class="codice">
            <h3>Ciclo for</h3>
            <pre><code>// Sintassi: for (inizializzazione; condizione; incremento)
for (let i = 0; i < 5; i++) {
    console.log(`Iterazione ${i}`);
}
// Stampa: 0, 1, 2, 3, 4

// Iterare su array con indice
const frutti = ["mela", "banana", "arancia"];
for (let i = 0; i < frutti.length; i++) {
    console.log(`${i}: ${frutti[i]}`);
}

// for...of (moderno): itera sui valori
for (const frutto of frutti) {
    console.log(frutto);  // "mela", "banana", "arancia"
}</code></pre>
        </div>

        <div class="codice">
            <h3>Ciclo while</h3>
            <pre><code>// while: esegue finché la condizione è vera
let contatore = 0;
while (contatore < 5) {
    console.log(contatore);
    contatore++;
}

// do...while: esegue almeno una volta
let numero = 0;
do {
    console.log(numero);
    numero++;
} while (numero < 5);

// Esempio pratico: cercare un elemento
const numeri = [10, 25, 30, 45, 60];
let trovato = false;
let indice = 0;

while (indice < numeri.length && !trovato) {
    if (numeri[indice] > 40) {
        trovato = true;
        console.log(`Trovato ${numeri[indice]} all'indice ${indice}`);
    }
    indice++;
}</code></pre>
        </div>

        <div class="codice">
            <h3>forEach e Array Methods</h3>
            <pre><code>// forEach: esegue una funzione per ogni elemento
const numeri = [1, 2, 3, 4, 5];

numeri.forEach(numero => {
    console.log(numero * 2);  // 2, 4, 6, 8, 10
});

// forEach con indice
const frutti = ["mela", "banana", "arancia"];
frutti.forEach((frutto, indice) => {
    console.log(`${indice}: ${frutto}`);
});

// ✅ Metodi moderni (preferiti)
// map: trasforma ogni elemento
const doppi = numeri.map(n => n * 2);  // [2, 4, 6, 8, 10]

// filter: filtra elementi
const pari = numeri.filter(n => n % 2 === 0);  // [2, 4]

// find: trova primo elemento
const maggioreDi3 = numeri.find(n => n > 3);  // 4</code></pre>
        </div>

        <h3>Esempio Pratico</h3>

        <div class="codice">
<pre><code>// Esempio reale: elaborazione ordini e-commerce
const ordini = [
    { id: 1, cliente: "Mario", totale: 150, stato: "spedito" },
    { id: 2, cliente: "Laura", totale: 200, stato: "in attesa" },
    { id: 3, cliente: "Carlo", totale: 75, stato: "spedito" },
    { id: 4, cliente: "Anna", totale: 300, stato: "consegnato" }
];

// forEach: inviare email di conferma
ordini.forEach(ordine => {
    if (ordine.stato === "spedito") {
        console.log(`Invio email a ${ordine.cliente} per ordine #${ordine.id}`);
    }
});

// map: estrarre lista clienti
const clienti = ordini.map(ordine => ordine.cliente);
console.log(clienti);  // ["Mario", "Laura", "Carlo", "Anna"]

// filter: ordini sopra €100
const ordiniGrandi = ordini.filter(ordine => ordine.totale > 100);
console.log(ordiniGrandi.length);  // 3

// find: cercare ordine specifico
const ordineMario = ordini.find(ordine => ordine.cliente === "Mario");
console.log(ordineMario);  // { id: 1, cliente: "Mario", ... }

// Calcolare totale vendite (reduce)
const totaleVendite = ordini.reduce((sum, ordine) => sum + ordine.totale, 0);
console.log(totaleVendite);  // 725</code></pre>
        </div>

        <h2>6. Template Literals</h2>

        <div class="teoria">
            <p>I <strong>template literals</strong> (o template strings) utilizzano i backtick (<code>`</code>) invece delle virgolette e permettono di inserire variabili ed espressioni JavaScript direttamente nella stringa usando la sintassi <code>${}</code>. Supportano anche stringhe multilinea senza caratteri di escape.</p>
            
            <h3>Vantaggi</h3>
            <ul>
                <li>Niente più concatenazione con <code>+</code></li>
                <li>Interpolazione di variabili e espressioni</li>
                <li>Stringhe multilinea native</li>
                <li>Più leggibile e meno errori di sintassi</li>
            </ul>
        </div>

        <div class="codice">
<pre><code>// ❌ Concatenazione vecchio stile
const nome = "Carlo";
const eta = 30;
const messaggio = "Mi chiamo " + nome + " e ho " + eta + " anni";

// ✅ Template literals con backtick `
const messaggio = `Mi chiamo ${nome} e ho ${eta} anni`;

// Espressioni dentro ${}
const prezzo = 100;
console.log(`Totale con IVA: ${prezzo * 1.22}€`);

// Multilinea senza \n
const html = `
    <div>
        <h1>${nome}</h1>
        <p>Età: ${eta}</p>
    </div>
`;</code></pre>
        </div>

        <h3>Esempio Pratico</h3>

        <div class="codice">
<pre><code>// Esempio reale: generare email personalizzata
function creaEmailBenvenuto(utente, ordine) {
    const oggetto = `Benvenuto ${utente.nome}! Ordine #${ordine.id} confermato`;
    
    const corpo = `
        Ciao ${utente.nome},
        
        Grazie per il tuo ordine!
        
        Riepilogo:
        - Prodotti: ${ordine.prodotti.length}
        - Totale: €${ordine.totale.toFixed(2)}
        - Spedizione prevista: ${ordine.dataSpedizione}
        
        Traccia il tuo ordine: www.example.com/ordini/${ordine.id}
        
        Il team di Example
    `;
    
    return { oggetto, corpo };
}

// Utilizzo
const email = creaEmailBenvenuto(
    { nome: "Mario" },
    { id: 12345, prodotti: ["Laptop"], totale: 999.99, dataSpedizione: "15/11/2024" }
);</code></pre>
        </div>

        <div class="teoria">
            <h2>Riepilogo Fondamenti JavaScript</h2>
            <table>
                <tr>
                    <th>Concetto</th>
                    <th>Quando Usarlo</th>
                </tr>
                <tr>
                    <td>const/let</td>
                    <td>Dichiarazione variabili (const di default)</td>
                </tr>
                <tr>
                    <td>Funzioni</td>
                    <td>Codice riutilizzabile, arrow functions per callback</td>
                </tr>
                <tr>
                    <td>Oggetti</td>
                    <td>Raggruppare dati correlati</td>
                </tr>
                <tr>
                    <td>Classi</td>
                    <td>Creare oggetti con stessa struttura</td>
                </tr>
                <tr>
                    <td>for/while</td>
                    <td>Iterazioni con contatore o condizione</td>
                </tr>
                <tr>
                    <td>forEach/map/filter</td>
                    <td>Elaborare array in modo moderno</td>
                </tr>
                <tr>
                    <td>Template literals</td>
                    <td>Stringhe con variabili (backtick)</td>
                </tr>
            </table>
        </div>

        <div class="navigazione">
            <a href="/lezione-5/index.html" class="btn-prev">← Indice Lezione</a>
            <a href="/index.html" class="btn-home">Home</a>
            <a href="/link-utili.html" class="btn-link-utili">Link Utili</a>
            <a href="/lezione-5/lezione-5-2.html" class="btn-next">Prossima Lezione →</a>
        </div>
    </div>
</body>
</html>